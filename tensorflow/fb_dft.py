import warnings
import tensorflow as tf


def analysis(x, bfr, w, hop_size, fft_size, shift):
    """
    DFT modulated filter bank analysis function.
    
    Inputs:
        x: input tensor; ideally, its length is a multiple of hop size (or frame step).
        bfr: analysis buffer state tensor.
        w: flipped analysis prototype filter. 
        hop_size: hop size.
        fft_size: FFT length.
        shift: the amount of circular shifting.         
    Outputs:
        first: transformed representation in the frequency domain. 
        second: updated analysis buffer state. 
    """
    batch, seq_len = x.shape
    filter_len = len(w)
    if seq_len%hop_size != 0:
        warnings.warn('Sequence length is not a multiple of hop size.')
    
    x = tf.concat([bfr, x], axis=-1)
    X = tf.signal.frame(x, filter_len, hop_size)
    bfr = X[:, -1, hop_size:]
    X = w*X
    X = tf.reshape(X, [batch, -1, filter_len//fft_size, fft_size])
    X = tf.reduce_sum(X, axis=-2)
    if shift!=0:
        X = tf.roll(X, shift, axis=-1)
    X = tf.signal.rfft(X)
    return [X, bfr]


def synthesis(X, bfr, w, hop_size, fft_size):
    """
    DFT modulated filter bank synthesis function. 
    No circular shifting here as for DFT modulation, one always can move all circular shiftings to the analysis side. 
    
    Inputs:
        X: transformed representation in the frequency domain.
        bfr: synthesis buffer state.
        w: synthesis prototype filter. 
        hop_size: hop size. 
        fft_size: FFT length.
        
    Outputs:
        first: recovered representation in the time domain.
        second: updated synthesis buffer state.
    """
    batch, seq_len = X.shape[0:2]
    filter_len = len(w)
    
    y = tf.signal.irfft(X, fft_length=[fft_size]) 
    y = w*tf.tile(y, [1,1, filter_len//fft_size])
    bfr = tf.concat([bfr, tf.zeros([batch, hop_size])], axis=-1)
    y = tf.signal.overlap_and_add(tf.concat([bfr[:,None,:] + y[:, :1], y[:, 1:]], axis=1), hop_size)
    return [y[:, :seq_len*hop_size], y[:, seq_len*hop_size:]]


class Analysis(tf.keras.layers.Layer):
    """
    DFT modulated filter bank analysis class. 
    """
    def __init__(self, fb, **kwargs):
        """
        fb is a filterbank object generated by my Matlab/Octave filter bank design script. 
        """
        super(Analysis, self).__init__(**kwargs)
        self.fft_size = tf.convert_to_tensor(fb['T'][0,0].item(), dtype=tf.int32)
        self.hop_size = tf.convert_to_tensor(fb['B'][0,0].item(), dtype=tf.int32)
        self.shift = tf.convert_to_tensor(fb['i'][0,0].item() + fb['j'][0,0].item() - 1, dtype=tf.int32)
        self.w = tf.convert_to_tensor(fb['h'][0,0].squeeze()[::-1], dtype=tf.float32)

    def call(self, x, bfr=None):
        """
        Transform time domain representation to frequency domain. 
        The analysis buffer is set to zero if not specified. 
        """
        if bfr is None:
            bfr = tf.zeros([x.shape[0], len(self.w)-self.hop_size])
        return analysis(x, bfr, self.w, self.hop_size, self.fft_size, self.shift)
    
    
class Synthesis(tf.keras.layers.Layer):
    """
    DFT modulated filter bank synthesis class.
    """
    def __init__(self, fb, **kwargs):
        """
        fb is a filterbank object generated by my Matlab/Octave filter bank design script. 
        """
        super(Synthesis, self).__init__(**kwargs)
        self.fft_size = tf.convert_to_tensor(fb['T'][0,0].item(), dtype=tf.int32)
        self.hop_size = tf.convert_to_tensor(fb['B'][0,0].item(), dtype=tf.int32)
        self.w = tf.convert_to_tensor(fb['g'][0,0].squeeze(), dtype=tf.float32)

    def call(self, X, bfr=None):
        """
        Transform frequency domain representation to the time domain. 
        The synthesis buffer is set to zero if not specified. 
        """
        if bfr is None:
            bfr = tf.zeros([X.shape[0], len(self.w)-self.hop_size])
        return synthesis(X, bfr, self.w, self.hop_size, self.fft_size)